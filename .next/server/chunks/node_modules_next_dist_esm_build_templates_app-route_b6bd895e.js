module.exports=[8922,e=>{"use strict";var t=e.i(47909),a=e.i(74017),i=e.i(96250),n=e.i(59756),s=e.i(61916),r=e.i(14444),o=e.i(37092),l=e.i(69741),c=e.i(16795),d=e.i(87718),u=e.i(95169),p=e.i(47587),m=e.i(66012),h=e.i(70101),g=e.i(26937),f=e.i(10372),v=e.i(93695);e.i(52474);var y=e.i(220),A=e.i(89171);let w=[{title:"3vltn",industry:"Domain Investment",description:"A premier domain selling and purchasing platform tailored for domain investors with AI-powered campaigns and autonomous deal closing.",results:["AI Email Agent","Automated Campaigns","Deal Closing"],image:"ðŸŒ",slug:"3vltn",screenshot:"/3vltn.png",fullDescription:"3vltn is a cutting-edge domain investment platform that revolutionizes how domain investors buy, sell, and market their domain portfolios. By leveraging advanced AI technology, the platform automates the entire sales process from campaign creation to deal closure.",challenge:"Domain investors struggled with manually reaching out to potential buyers, creating effective marketing campaigns, and managing negotiations across hundreds of domains. The traditional approach was time-consuming and often resulted in missed opportunities.",solution:"We developed an AI-powered platform that automatically creates targeted marketing campaigns for each domain in an investor's portfolio. The AI email agent engages with potential buyers, answers questions, negotiates prices, and closes deals autonomously, allowing investors to scale their operations dramatically.",technologies:["Next.js","OpenAI GPT-4","Python","PostgreSQL","Redis","Stripe"],keyFeatures:["AI-generated marketing campaigns tailored to each domain's niche","Autonomous email agent that handles customer conversations","Intelligent pricing recommendations based on market data","Automated deal closing and payment processing","Portfolio analytics and performance tracking","Integration with major domain registrars"],impact:[{metric:"Deal Closure Rate",value:"+250%"},{metric:"Time Saved",value:"40 hrs/week"},{metric:"Revenue Increase",value:"+180%"}]},{title:"lmn8 Ketamine Therapy AI",industry:"Healthcare & AI",description:"An innovative platform connecting ketamine therapy clinics with patients, streamlining the intake and matching process through AI.",results:["Patient-Clinic Matching","AI Screening","Appointment Management"],image:"ðŸ¥",slug:"lmn8-ketamine-therapy",screenshot:"/lmn8.png",fullDescription:"lmn8 is a healthcare technology platform that bridges the gap between ketamine therapy clinics and patients seeking treatment. The platform uses AI to match patients with the most suitable clinics based on their specific needs, location, and treatment requirements.",challenge:"Patients seeking ketamine therapy faced difficulty finding qualified clinics, while clinics struggled with inefficient intake processes and patient screening. The lack of a centralized platform made it hard for both parties to connect effectively.",solution:"We built an intelligent matching platform that uses AI to pre-screen patients, assess their suitability for ketamine therapy, and connect them with appropriate clinics. The system automates appointment scheduling, intake forms, and follow-up communications.",technologies:["React Native","Node.js","MongoDB","AWS","Twilio","HIPAA-compliant infrastructure"],keyFeatures:["AI-powered patient-clinic matching algorithm","Automated pre-screening questionnaires","Secure HIPAA-compliant data handling","Integrated appointment scheduling system","Telehealth consultation support","Patient progress tracking and analytics"],impact:[{metric:"Patient Matching Accuracy",value:"94%"},{metric:"Intake Time Reduction",value:"-65%"},{metric:"Clinic Capacity Increase",value:"+45%"}]},{title:"Faithful Companion",industry:"Mobile Application",description:"A dedicated spiritual companion app for the Christian community, offering daily devotionals, prayer support, and church integration.",results:["Daily Devotionals","Prayer Community","Church Finder"],image:"âœï¸",slug:"faithful-companion",screenshot:"/faithful-companion.png",fullDescription:"Faithful Companion is a comprehensive mobile application designed to support Christians in their daily spiritual journey. Similar to popular Islamic apps, it provides a centralized platform for prayer, scripture reading, community engagement, and church discovery.",challenge:"While there were several Islamic spiritual apps available, the Christian community lacked a comprehensive, modern app that combined devotionals, prayer tracking, community features, and church integration in one seamless experience.",solution:"We created a beautifully designed mobile app that serves as a daily spiritual companion. The app includes curated devotionals, Bible reading plans, prayer request sharing, church finder with event integration, and a supportive community platform.",technologies:["React Native","Firebase","GraphQL","Google Maps API","Push Notifications"],keyFeatures:["Daily devotionals and scripture readings","Personalized Bible reading plans","Community prayer request board","Church finder with location-based search","Event calendar and reminders","Prayer journal and tracking","Audio Bible and worship music integration"],impact:[{metric:"Daily Active Users",value:"50K+"},{metric:"Prayer Requests Shared",value:"200K+"},{metric:"App Store Rating",value:"4.8/5"}]},{title:"RV Park AI Voice Agent",industry:"Voice AI Automation",description:"A specialized AI voice agent designed for RV parks across the US, handling reservations, inquiries, and customer service calls 24/7.",results:["24/7 Availability","Automated Bookings","Customer Support"],image:"ðŸš",slug:"rv-park-voice-agent",screenshot:"/rv-park.png",fullDescription:"The RV Park AI Voice Agent is an intelligent phone system that handles all incoming calls for RV parks, from reservation inquiries to amenity questions. The AI agent understands natural language, accesses real-time availability, and can complete bookings without human intervention.",challenge:"RV parks often operate with limited staff and struggle to answer calls during peak seasons or after hours. Missed calls translate directly to lost revenue, and staff time spent on phone inquiries reduces time available for on-site customer service.",solution:"We developed a sophisticated voice AI agent that integrates with the park's reservation system. The agent can check availability, quote prices, explain amenities, answer FAQs, and complete bookings. It operates 24/7 and can handle multiple calls simultaneously.",technologies:["OpenAI Whisper","ElevenLabs Voice AI","Twilio","Python","FastAPI","PostgreSQL"],keyFeatures:["Natural language understanding and conversation","Real-time availability checking","Automated reservation booking and confirmation","FAQ answering about park amenities and policies","Multi-language support","Integration with existing park management systems","Call analytics and reporting"],impact:[{metric:"Call Answer Rate",value:"100%"},{metric:"Booking Conversion",value:"+85%"},{metric:"Staff Time Saved",value:"30 hrs/week"}]},{title:"Spectrum Voice Agent",industry:"Enterprise Sales AI",description:"A high-performance voice agent developed for Spectrum to automate sales calls, qualify leads, and close deals efficiently.",results:["Sales Automation","Lead Qualification","Custom Interface"],image:"ðŸ“ž",slug:"spectrum-voice-agent",screenshot:"/spectrum.png",fullDescription:"The Spectrum Voice Agent is an enterprise-grade AI sales representative that handles outbound and inbound sales calls for Spectrum. The agent qualifies leads, presents service packages, handles objections, and closes deals with a natural, conversational approach.",challenge:"Spectrum needed to scale their sales operations without proportionally increasing headcount. Traditional sales calls were expensive, inconsistent in quality, and limited by human availability. Lead qualification was time-consuming and often inaccurate.",solution:"We built a sophisticated voice AI system that mimics top-performing sales representatives. The agent uses advanced NLP to understand customer needs, presents tailored solutions, handles objections intelligently, and closes deals. A custom dashboard provides real-time monitoring and analytics.",technologies:["GPT-4 Turbo","Custom Voice Models","WebRTC","React","Node.js","MongoDB","AWS"],keyFeatures:["Advanced natural language processing for sales conversations","Dynamic script adaptation based on customer responses","Real-time objection handling","Automated deal closing and processing","Custom monitoring interface with live call tracking","Performance analytics and A/B testing","CRM integration for seamless data flow"],impact:[{metric:"Sales Calls Handled",value:"10K+/month"},{metric:"Conversion Rate",value:"+45%"},{metric:"Cost Reduction",value:"-70%"}]},{title:"Lead Generation Tools",industry:"Marketing Tools",description:"A suite of powerful lead generation tools designed to identify, qualify, and engage potential prospects across various industries.",results:["Multi-Channel Scraping","CRM Integration","Auto Outreach"],image:"ðŸŽ¯",slug:"lead-generation-tools",screenshot:"/lead-gen.png",fullDescription:"Our Lead Generation Tools suite is a comprehensive platform that automates the entire lead generation process. From identifying potential prospects across multiple channels to qualifying them and initiating outreach, the tools streamline what traditionally takes weeks into hours.",challenge:"Businesses struggled with manual lead generation processes that were time-consuming, inconsistent, and difficult to scale. Data was scattered across multiple sources, qualification was subjective, and outreach was often delayed or forgotten.",solution:"We created an integrated suite of tools that scrapes data from multiple sources, enriches it with additional information, scores and qualifies leads using AI, and automatically initiates personalized outreach campaigns. Everything integrates seamlessly with major CRMs.",technologies:["Python","Scrapy","OpenAI API","PostgreSQL","Redis","Celery","React"],keyFeatures:["Multi-channel data scraping (LinkedIn, websites, directories)","AI-powered lead scoring and qualification","Automated email and LinkedIn outreach sequences","Data enrichment with company and contact information","Integration with Salesforce, HubSpot, and other CRMs","Custom filters and targeting criteria","Performance analytics and ROI tracking"],impact:[{metric:"Leads Generated",value:"50K+/month"},{metric:"Time Saved",value:"-90%"},{metric:"Qualified Lead Rate",value:"+120%"}]}];function R(){let e="https://theprimecrafters.com";return[{url:`${e}/`,lastModified:new Date},{url:`${e}/portfolio`,lastModified:new Date},...w.map(t=>({url:`${e}/case-study/${t.slug}`,lastModified:new Date}))]}e.s(["default",()=>R],89282);var C=e.i(73853);async function b(){let e=await R(),t=(0,C.resolveRouteData)(e,"sitemap");return new A.NextResponse(t,{headers:{"Content-Type":"application/xml","Cache-Control":"public, max-age=0, must-revalidate"}})}e.s(["GET",()=>b],39248),e.i(39248),e.i(89282),e.s(["GET",()=>b],21330);var k=e.i(21330);let I=new t.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/sitemap.xml/route",pathname:"/sitemap.xml",filename:"sitemap--route-entry",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/app/sitemap--route-entry.js",nextConfigOutput:"",userland:k}),{workAsyncStorage:T,workUnitAsyncStorage:P,serverHooks:S}=I;function E(){return(0,i.patchFetch)({workAsyncStorage:T,workUnitAsyncStorage:P})}async function x(e,t,i){I.isDev&&(0,n.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let A="/sitemap.xml/route";A=A.replace(/\/index$/,"")||"/";let w=await I.prepare(e,t,{srcPage:A,multiZoneDraftMode:!1});if(!w)return t.statusCode=400,t.end("Bad Request"),null==i.waitUntil||i.waitUntil.call(i,Promise.resolve()),null;let{buildId:R,params:C,nextConfig:b,parsedUrl:k,isDraftMode:T,prerenderManifest:P,routerServerContext:S,isOnDemandRevalidate:E,revalidateOnlyGenerated:x,resolvedPathname:q,clientReferenceManifest:D,serverActionsManifest:M}=w,N=(0,l.normalizeAppPath)(A),O=!!(P.dynamicRoutes[N]||P.routes[q]),F=async()=>((null==S?void 0:S.render404)?await S.render404(e,t,k,!1):t.end("This page could not be found"),null);if(O&&!T){let e=!!P.routes[q],t=P.dynamicRoutes[N];if(t&&!1===t.fallback&&!e){if(b.experimental.adapterPath)return await F();throw new v.NoFallbackError}}let H=null;!O||I.isDev||T||(H="/index"===(H=q)?"/":H);let _=!0===I.isDev||!O,j=O&&!_;M&&D&&(0,r.setReferenceManifestsSingleton)({page:A,clientReferenceManifest:D,serverActionsManifest:M,serverModuleMap:(0,o.createServerModuleMap)({serverActionsManifest:M})});let L=e.method||"GET",U=(0,s.getTracer)(),B=U.getActiveScopeSpan(),V={params:C,prerenderManifest:P,renderOpts:{experimental:{authInterrupts:!!b.experimental.authInterrupts},cacheComponents:!!b.cacheComponents,supportsDynamicResponse:_,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:b.cacheLife,waitUntil:i.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,a,i)=>I.onRequestError(e,t,i,S)},sharedContext:{buildId:R}},K=new c.NodeNextRequest(e),W=new c.NodeNextResponse(t),$=d.NextRequestAdapter.fromNodeNextRequest(K,(0,d.signalFromNodeResponse)(t));try{let r=async e=>I.handle($,V).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let a=U.getRootSpanAttributes();if(!a)return;if(a.get("next.span_type")!==u.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${a.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let i=a.get("next.route");if(i){let t=`${L} ${i}`;e.setAttributes({"next.route":i,"http.route":i,"next.span_name":t}),e.updateName(t)}else e.updateName(`${L} ${A}`)}),o=!!(0,n.getRequestMeta)(e,"minimalMode"),l=async n=>{var s,l;let c=async({previousCacheEntry:a})=>{try{if(!o&&E&&x&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let s=await r(n);e.fetchMetrics=V.renderOpts.fetchMetrics;let l=V.renderOpts.pendingWaitUntil;l&&i.waitUntil&&(i.waitUntil(l),l=void 0);let c=V.renderOpts.collectedTags;if(!O)return await (0,m.sendResponse)(K,W,s,V.renderOpts.pendingWaitUntil),null;{let e=await s.blob(),t=(0,h.toNodeOutgoingHttpHeaders)(s.headers);c&&(t[f.NEXT_CACHE_TAGS_HEADER]=c),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let a=void 0!==V.renderOpts.collectedRevalidate&&!(V.renderOpts.collectedRevalidate>=f.INFINITE_CACHE)&&V.renderOpts.collectedRevalidate,i=void 0===V.renderOpts.collectedExpire||V.renderOpts.collectedExpire>=f.INFINITE_CACHE?void 0:V.renderOpts.collectedExpire;return{value:{kind:y.CachedRouteKind.APP_ROUTE,status:s.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:a,expire:i}}}}catch(t){throw(null==a?void 0:a.isStale)&&await I.onRequestError(e,t,{routerKind:"App Router",routePath:A,routeType:"route",revalidateReason:(0,p.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:E})},S),t}},d=await I.handleResponse({req:e,nextConfig:b,cacheKey:H,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:P,isRoutePPREnabled:!1,isOnDemandRevalidate:E,revalidateOnlyGenerated:x,responseGenerator:c,waitUntil:i.waitUntil,isMinimalMode:o});if(!O)return null;if((null==d||null==(s=d.value)?void 0:s.kind)!==y.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==d||null==(l=d.value)?void 0:l.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});o||t.setHeader("x-nextjs-cache",E?"REVALIDATED":d.isMiss?"MISS":d.isStale?"STALE":"HIT"),T&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let u=(0,h.fromNodeOutgoingHttpHeaders)(d.value.headers);return o&&O||u.delete(f.NEXT_CACHE_TAGS_HEADER),!d.cacheControl||t.getHeader("Cache-Control")||u.get("Cache-Control")||u.set("Cache-Control",(0,g.getCacheControlHeader)(d.cacheControl)),await (0,m.sendResponse)(K,W,new Response(d.value.body,{headers:u,status:d.value.status||200})),null};B?await l(B):await U.withPropagatedContext(e.headers,()=>U.trace(u.BaseServerSpan.handleRequest,{spanName:`${L} ${A}`,kind:s.SpanKind.SERVER,attributes:{"http.method":L,"http.target":e.url}},l))}catch(t){if(t instanceof v.NoFallbackError||await I.onRequestError(e,t,{routerKind:"App Router",routePath:N,routeType:"route",revalidateReason:(0,p.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:E})}),O)throw t;return await (0,m.sendResponse)(K,W,new Response(null,{status:500})),null}}e.s(["handler",()=>x,"patchFetch",()=>E,"routeModule",()=>I,"serverHooks",()=>S,"workAsyncStorage",()=>T,"workUnitAsyncStorage",()=>P],8922)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_b6bd895e.js.map